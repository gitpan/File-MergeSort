.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MergeSort 3"
.TH MergeSort 3 "2003-05-25" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
File::MergeSort \- Mergesort ordered files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use File::MergeSort;
.Ve
.PP
.Vb 5
\& # Create the MergeSort object.
\& my $sort = new File::MergeSort( 
\&                [ $file_1, ..., $file_n ],  # Anonymous array of input files
\&                \e&extract_function,         # Sub to extract merge key
\&                );
.Ve
.PP
.Vb 3
\& # Retrieve the next line for processing
\& my $line = $sort->next_line;
\& print $line, "\en";
.Ve
.PP
.Vb 2
\& # Dump remaining records in sorted order to a file.
\& $sort->dump( $file );    # Omit $file to default to STDOUT
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::MergeSort provides methods to merge and process a number of
\&\fBpre-sorted\fR files into a single sorted output.
.PP
Merge keys are extracted from the input lines using a user defined
subroutine. Comparisons on the keys are done lexicographically.
.PP
Plaintext and compressed (.z or .gz) files are catered for.
\&\f(CW\*(C`IO::Zlib\*(C'\fR is used to handle compressed files.
.PP
File::MergeSort is a hopefully straightforward solution for situations
where one wishes to merge data files with presorted records. An
example might be application server logs which record events
chronologically from a cluster.
.Sh "\s-1POINTS\s0 \s-1TO\s0 \s-1NOTE\s0"
.IX Subsection "POINTS TO NOTE"
Comparisons on the merge keys are carried out lexicographically. The
user should ensure that the subroutine used to extract merge keys
formats the keys if required so that they sort correctly.
.PP
Note that earlier versions (< 1.06) of File::MergeSort preformed
numeric, not lexicographical comparisons.
.Sh "\s-1DETAILS\s0"
.IX Subsection "DETAILS"
The user is expected to supply a list of file pathnames and a function
to extract an index value from each record line (the merge key).
.PP
By calling the \*(L"next_line\*(R" or \*(L"dump\*(R" function, the user can retrieve
the records in an ordered manner.
.PP
As arguments, MergeSort takes a reference to an anonymous array of
file paths/names and a reference to a subroutine that extracts a merge
key from a line.
.PP
The anonymous array of the filenames are the files to be sorted with
the subroutine determining the sort order.
.PP
For each file MergeSort opens the file using IO::File or IO::Zlib for
compressed files.  MergeSort handles mixed compressed and uncompressed
files seamlessly by detecting for files with .z or .gz extensions.
.PP
When passed a line (a scalar, passed as the first and only argument,
\&\f(CW$_\fR[0]) from one of the files, the user supplied subroutine must return
the merge key for the line.
.PP
The records are then output in ascending order based on the merge
keys returned by the user supplied subroutine.
A stack is created based on the merge keys returned by the subroutine.
.PP
When the \f(CW\*(C`next_line\*(C'\fR method is called, File::MergeSort returns the
line with the lowest merge key/value.
.PP
File::MergeSort then replenishes the stack, reads a new line from the
corresponding file and places it in the proper position for the next
call to \f(CW\*(C`next_line\*(C'\fR.
.PP
If a simple merge is required, without any user processing of each
line read from the input files, the \f(CW\*(C`dump\*(C'\fR method can be used to read
and merge the input files into the specified output file, or to \s-1STDOUT\s0
if no file is specified.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "new( \s-1ARRAY_REF\s0, \s-1CODE_REF\s0 );" 4
.IX Item "new( ARRAY_REF, CODE_REF );"
Create a new \f(CW\*(C`File::MergeSort\*(C'\fR object.
.Sp
There are two required arguments:
.Sp
A reference to an array of files to read from.
These files can be either plaintext, or compressed.
Any file with a .gz or .z suffix will be opened using \f(CW\*(C`IO::Zlib\*(C'\fR.
.Sp
A code reference. When called, the coderef should return the merge key
for a line, which is given as the only argument to that
subroutine/coderef.
.SH "METHODS"
.IX Header "METHODS"
.IP "next_line( );" 4
.IX Item "next_line( );"
Returns the next line from the merged input files.
.IP "dump( [ \s-1FILENAME\s0 ] );" 4
.IX Item "dump( [ FILENAME ] );"
Reads and merges from the input files to \s-1FILENAME\s0, or \s-1STDOUT\s0 if
\&\s-1FILENAME\s0 is not given, until all files have been exhausted.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\&  # This program looks at files found in /logfiles, returns the
\&  # records of the files sorted by the date in mm/dd/yyyy format
.Ve
.PP
.Vb 1
\&  use File::MergeSort;
.Ve
.PP
.Vb 4
\&  my $files = qw[ logfiles/log_server_1.log
\&                  logfiles/log_server_2.log
\&                  logfiles/log_server_3.log
\&                ];
.Ve
.PP
.Vb 1
\&  my $sort = File::MergeSort->new( $files, \e&index_sub );
.Ve
.PP
.Vb 3
\&  while (my $line = $sort->next_line) {
\&     # some operations on $line
\&  }
.Ve
.PP
.Vb 1
\&  sub index_sub{
.Ve
.PP
.Vb 1
\&    # Use this to extract a date of the form mm-dd-yyyy.
.Ve
.PP
.Vb 1
\&    my $line = shift;
.Ve
.PP
.Vb 2
\&    # Be cautious that only the date will be extracted.
\&    $line =~ /(\ed{2})-(\ed{2})-(\ed{4})/;
.Ve
.PP
.Vb 3
\&    return "$3$1$2";  # Index is an interger, yyyymmdd
\&                      # Lower number will be read first.
\&  }
.Ve
.PP
.Vb 3
\&  # This slightly more compact example performs a simple merge of
\&  # several input files with fixed width merge keys into a single
\&  # output file.
.Ve
.PP
.Vb 1
\&  use File::MergeSort;
.Ve
.PP
.Vb 2
\&  my $files   = qw [ input_1 input_2 input_3 ];
\&  my $extract = sub { substr($_[0], 15, 10 ) };  # To substr merge key out of line
.Ve
.PP
.Vb 1
\&  my $sort = File::MergeSort->new( $files, $extract );
.Ve
.PP
.Vb 1
\&  $sort->dump( "output_file" );
.Ve
.SH "TODO"
.IX Header "TODO"
.Vb 3
\& + Implement a generic test/comparison function to replace text/numeric comparison.
\& + Implement a configurable record seperator.
\& + Allow for optional deletion of duplicate entries.
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
Nothing. \s-1OO\s0 interface. See \s-1CONSTRUCTOR\s0 and \s-1METHODS\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Brown: <chris.brown@cal.berkeley.edu>
.PP
Copyright(c) 2003 Christopher Brown.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, IO::File, IO::Zlib,  Compress::Zlib.
.PP
File::Sort as an alternative.
